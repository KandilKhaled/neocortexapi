
The HtmlSerializer class is a class that allows you to convert an object to an HTML string representation.
To use the HtmlSerializer class, you would typically create an instance of the class and call its Serialize method, passing in the object that you want to serialize.

A Serialize method is a method that converts an object to a specific format, such as XML, JSON, or binary. The purpose of serialization is to convert an object's state to a format that can be stored or transmitted over a network,
and then later restored to its original state using a process called deserialization.

There are several types that cannot be serialized:

Static classes: Static classes are not instantiated, and therefore cannot be serialized.
Open generic types: These types are not bound to a specific type parameter and cannot be serialized.
Delegate types: Delegates are not serializable, but their invocation lists can be serialized.
    A delegate type is similar to a function pointer in C or C++. A delegate is a reference type, and it can be used to encapsulate a method so that it can be passed around as a value.
Anonymous types: Anonymous types are not serializable because they don't have a defined type name
    Anonymous types are types that are generated by the compiler at runtime and don't have a defined type name. They are used to create an object with a set of properties and values, without having to explicitly define a class.
Some other types: Types that implement the IDeserializationCallback interface, the ISerializable interface, or the IObjectReference interface can also not be serialized.


- The methods SerializeBegin and SerializeEnd are both methods that use sw.Write(). In the proyect it says we should name this mehtods SerializeValue, 
but they are not serializing any value itself, just saying when is the start and end of the serialize object, so I propose to call them SerializeObject instead
Also we can make the code more compact by doing only one mehtod:

public void SerializeObject(String typeName, StreamWriter sw, bool isBegin)
{
    sw.WriteLine();
    if (isBegin)
    {
        sw.Write($"{TypeDelimiter} BEGIN '{typeName}' {TypeDelimiter}");
    }
    else
    {
        sw.Write($"{TypeDelimiter} END '{typeName}' {TypeDelimiter}");
    }
    sw.WriteLine();
}

- Because everytime in the code it is use the SerializeValue you have to acutally indicates the type of the parameters,
maybe an option is to create a new method that regardless of the type of parameter, works:

public void SerializeValue<TKey, TValue>(Dictionary<TKey, TValue> keyValues, StreamWriter sw)
{
    sw.Write(ValueDelimiter);
    foreach (KeyValuePair<TKey, TValue> i in keyValues)
    {
        sw.Write(i.Key.ToString() + KeyValueDelimiter + i.Value.ToString());
        sw.Write(ElementsDelimiter);
    }
    sw.Write(ParameterDelimiter);
}

