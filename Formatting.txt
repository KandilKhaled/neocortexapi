Note: the letter after the number of the method indicates if the method itself should go into the formatting class (F) or the serializing/deserializing class (S)
The number in inside () refers to the number of the line in the code which the method is used

 **Method 1F (1601): Serializing the array Cell values into a Streamwriter.**
public void SerializeValue(Cell[] val, StreamWriter sw)
        {
            //Writes a delimter value and while this value is diferent from 0, 
            //it goes through the values one by one. First calling the method SerializeT and after writing the delimer value
            sw.Write(ValueDelimiter);
            if (val != null)
            {
                foreach (Cell cell in val)
                {
                    cell.SerializeT(sw);
                    sw.Write(ValueDelimiter);
                }
            }
            sw.Write(ParameterDelimiter);
        }


**Method 2S (188): Method SerializeT**
   public void SerializeT(StreamWriter writer)
        {
            //Creates a new  HtmSerializer instance/object 
            HtmSerializer ser = new HtmSerializer();

            //Calling SerializeBegin method with the value of the Cell (array) as the parameter
            ser.SerializeBegin(nameof(Cell), writer);

            //Serializing the properties of the Cell
            ser.SerializeValue(this.Index, writer);
            //ser.SerializeValue(this.CellId, writer);
            ser.SerializeValue(this.ParentColumnIndex, writer);

            if (this.DistalDendrites != null && this.DistalDendrites.Count > 0)
                ser.SerializeValue(this.DistalDendrites, writer);

            if (this.ReceptorSynapses != null && this.ReceptorSynapses.Count > 0)
                ser.SerializeValue(this.ReceptorSynapses, writer);

            ser.SerializeEnd(nameof(Cell), writer);


        }


**Method 3F (50): method SerializeBegin**
  public void SerializeBegin(String typeName, StreamWriter sw)
        {
            //
            // -- BEGIN ---
            // typeName
            
            //Writing a new line in the StreamWriter. This is use to move to the next line once we are done writing in the current line
            //Very usuful to make easier the reading
            sw.WriteLine();

            //Writing the string into the text Stream. This string indicates the start of the serialize object 'BEGIN' (typeName)
            sw.Write($"{TypeDelimiter} BEGIN '{typeName}' {TypeDelimiter}");
            sw.WriteLine();

        }


**Method 4F (26): method SerializeValue**
 public void SerializeValue(double val, StreamWriter sw)
        {            
            //allows you to format a string using placeholders and values. 
            //It replaces placeholders in the string with the corresponding values.
            //A placeholder is  used in a format string to indicate where a variable value should be inserted.
            //In our case {0:0.00} : the first 0 is indicating that is going to use the first argument passed to the method 
            // The 0.00 means the format of the argument. So our number is going to be a two decimal value
            //By using CultureInfo.InvariantCulture you can ensure that the formatting of the data is consistent across different cultures and locales. 
            //Culture meaning the setting of the computer running the code (language, format (DD/MM/YY))
            //We are formatting the argument pass to the method ensuring everytime this process is going to stay the same
            sw.Write(string.Format(CultureInfo.InvariantCulture, "{0:0.00}", val));
            
            //Writes the value of the delimeter variable into the stream. 
            //This is used so when reading the serialize data, the computer knows when one serialize value ends and another beggins
            sw.Write(delimiter);
        }


**Method 5F (108):method SerializeEnd**
public void SerializeEnd(String typeName, StreamWriter sw)
        {
            sw.WriteLine();
            //It is indicating the end of the serialize object
            sw.Write($"{TypeDelimiter} END '{typeName}' {TypeDelimiter}");
            sw.WriteLine();
        }

**Method 6S (1619): Deserializing the array Cell values **
public Cell[] DeserializeCellArray(string data, StreamReader reader)
        {
            //Create an new empty list of Cell objects. 
            //We will storage the deserilize cell objects in the list once they are read
            List<Cell> cells = new List<Cell>();
            
            //Is the input data the beggining of the object? Calling the method ReadBegin
            if (data == ReadBegin(nameof(Cell)))
            {
                //if so, calling the Deserialize method a creating a new object Cell
                Cell cell1 = Cell.Deserialize(reader);

                //Checking properties of the Cell
                if (cell1.DistalDendrites.Count != 0)
                {

                    DistalDendrite distSegment1 = cell1.DistalDendrites[0];

                    DistalDendrite distSegment2 = cell1.DistalDendrites[1];


                    distSegment1.ParentCell = cell1;
                    distSegment2.ParentCell = cell1;
                }
                //the object cell1 is add to the list of Cell
                cells.Add(cell1);
            }
            
           //reader.Peek() is a method of the StreamData
           //While there is more data to be read from the StreamData, read
            while (reader.Peek() >= 0)
            {
                string val = reader.ReadLine();

                if (val == ReadBegin(nameof(Cell)))
                {
                    //Calling the deserialize method
                    Cell cell1 = Cell.Deserialize(reader);
                    //Checking the properties of the Cell
                    if (cell1.DistalDendrites.Count != 0)
                    {
                        DistalDendrite distSegment1 = cell1.DistalDendrites[0];

                        DistalDendrite distSegment2 = cell1.DistalDendrites[1];

                        distSegment1.ParentCell = cell1;
                        distSegment2.ParentCell = cell1;
                    }
                    cells.Add(cell1);

                }
            }

            //Converting the list of cell to a array
            Cell[] cells1 = cells.ToArray();
            return cells1;
        }


**Mehtod 7 (1668): deserializing a single Cell object**
public Cell DeserializeCell(StreamReader sr)
        {
            //While there is more data to be read from the StreamData, read
            while (sr.Peek() >= 0)
            {
                string data = sr.ReadLine();

                if (data == ReadBegin(nameof(Cell)))
                {
                    Cell cell1 = Cell.Deserialize(sr);

                    DistalDendrite distSegment1 = cell1.DistalDendrites[0];

                    DistalDendrite distSegment2 = cell1.DistalDendrites[1];

                    distSegment1.ParentCell = cell1;
                    distSegment2.ParentCell = cell1;

                    return cell1;
                }
            }
            //when there is no more to read, stop
            return null;
        }


*Note: the main diference between the method 6 and 7 is that even though they both are deserializing, 
the 6 Mehtod returns an array of Cell object while the 7 returns a single Cell object.
But in the end the method itself is the same, it only changes the return value.*


**Mehtod 8F (1716): **
 public void SerializeValue(Dictionary<String, int> keyValues, StreamWriter sw)
        {
            sw.Write(ValueDelimiter);
            foreach (KeyValuePair<string, int> i in keyValues)
            {
                //Writing the Key and Value into the StreamWriter. 
                //Because the Value is a int, we need to transform it to a string
                sw.Write(i.Key + KeyValueDelimiter + i.Value.ToString());
                
                //Each key and Value is separated by a KeyValueDelimeter. 
                //While each pair of these parameters is separated by the ElementsDelimiter
                sw.Write(ElementsDelimiter);
            }
            sw.Write(ParameterDelimiter);
        }


**Method 9F (1750): **
 public void SerializeValue(Dictionary<int, int> keyValues, StreamWriter sw)
        {
            sw.Write(ValueDelimiter);
            foreach (KeyValuePair<int, int> i in keyValues)
            {
                sw.Write(i.Key.ToString() + KeyValueDelimiter + i.Value.ToString());
                sw.Write(ElementsDelimiter);
            }
            sw.Write(ParameterDelimiter);
        }

*Note: the diference between mehtod 8 and 9 is that while in the 8 the properties of Dictionary (key and value) are a 
string and a int, int the 9, bot properties are ints. 
To do a more generic method we could cahnge the specific type for the type paramerters. 
This means that regardless of the type of parameter Key and Value, the method will still work:*
public void SerializeValue<TKey, TValue>(Dictionary<TKey, TValue> keyValues, StreamWriter sw)
{
    sw.Write(ValueDelimiter);
    foreach (KeyValuePair<TKey, TValue> i in keyValues)
    {
        sw.Write(i.Key.ToString() + KeyValueDelimiter + i.Value.ToString());
        sw.Write(ElementsDelimiter);
    }
    sw.Write(ParameterDelimiter);
}

*Note: there are more SerializeValue methods, but in the end they all do the same. The main diference is the format of the serializes
values and the type of parameters (int, array, etc) we want to serialize.*